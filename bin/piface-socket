#!/usr/bin/env python

import socket
import sys
import os

import json

if len(sys.argv) < 2:
    sys.exit('Usage: %s <socket-file-path>' % sys.argv[0])

server_address = sys.argv[1]

debug = os.getenv('DEBUG', False)
if debug:
    print 'Starting web server for debug'
    from piface_web import web, pifacecad
else:
    import pifacecad

cad = pifacecad.PiFaceCAD()

# Make sure the socket does not already exist
try:
    os.unlink(server_address)
except OSError:
    if os.path.exists(server_address):
        raise

# Create a UDS socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

# Bind the socket to the port
print >>sys.stderr, 'starting up on %s' % server_address
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)

def init_lcd():
    cad.lcd.blink_off()
    cad.lcd.clear()
    cad.lcd.cursor_off()

init_lcd()

sys.path.append(os.path.abspath( __file__ + "/../.."))
from piface_web import line_reader
reader = line_reader.LineReader()

# while True:
# Wait for a connection
print >>sys.stderr, 'waiting for a connection'
connection, client_address = sock.accept()

def handle_lcd_write(lines):
    cad.lcd.clear()
    cad.lcd.set_cursor(0, 0)
    cad.lcd.write(lines[0])
    if lines[1]:
        cad.lcd.set_cursor(0, 1)
        cad.lcd.write(lines[1])

def handle_button_event(event):
    print event
    data = {'type': 'button', 'id': event.pin_num, 'value': 1}
    print 'handle_button_event'
    print data
    connection.sendall(json.dumps(data))

def handle_incoming_message(msg):
    data = json.loads(msg)
    if data['type'] == 'display':
        handle_lcd_write(data['lines'])

listener = pifacecad.SwitchEventListener(chip=cad)
for pin in range(0, 8):
    listener.register(pin, pifacecad.IODIR_RISING_EDGE, handle_button_event)
listener.activate()

try:
    print >>sys.stderr, 'connection from', client_address

    # Receive the data in small chunks and retransmit it
    while True:

        data = connection.recv(4096)

        if len(data) == 0:
            print 'socket has closed'
            break;

        reader.push(data)
        messages = reader.process()

        if messages:
            print "Received %i messages" % len(messages)

            for msg in messages:
                handle_incoming_message(msg)

        # print >>sys.stderr, 'received "%s"' % data
        # if data:
        #     print 'got data'
        #     # print >>sys.stderr, 'sending data back to the client'
        #     # connection.sendall(data)
        # else:
        #     print >>sys.stderr, 'no more data from', client_address
        #     # break
finally:
    # Clean up the connection
    print "Cleaning up connection"
    connection.close()